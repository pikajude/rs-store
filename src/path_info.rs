use crate::{hash::Hash, path::Path};
use std::{collections::BTreeSet, time::SystemTime};

#[derive(getset::Getters, getset::CopyGetters)]
pub struct ValidPathInfo {
  #[getset(get = "pub")]
  store_path: Path,
  deriver: Option<Path>,
  #[getset(get = "pub")]
  nar_hash: Hash,
  #[getset(get = "pub")]
  references: BTreeSet<Path>,
  #[getset(get_copy = "pub")]
  registration_time: SystemTime,
  #[getset(get_copy = "pub")]
  nar_size: u64,
  pub(crate) id: u64,
  #[getset(get = "pub")]
  signatures: BTreeSet<String>,
  content_addressed: Option<String>,
}

impl ValidPathInfo {
  pub fn deriver(&self) -> Option<&Path> {
    self.deriver.as_ref()
  }

  /// An assertion that this derivation is content-addressed (the hash is
  /// generated by the contents, not the derivation.)
  pub fn content_addressed(&self) -> Option<&str> {
    self.content_addressed.as_deref()
  }
}

impl PartialEq for ValidPathInfo {
  fn eq(&self, other: &Self) -> bool {
    self.store_path == other.store_path
      && self.nar_hash == other.nar_hash
      && self.references == other.references
  }
}

impl Eq for ValidPathInfo {}
